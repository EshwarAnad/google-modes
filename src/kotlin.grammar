include "./javadoc.grammar" as doccomment

start top {
  shebang? l (TopItem (whitespace | "\n")*)+
}

skip skipAny {
  Declaration {
    ClassDeclaration |
    ObjectDeclaration |
    fun TypeParams? declName FunctionSpec |
    PropertyDeclaration |
    TypeAlias
  }

  ClassDeclaration {
    (class | interface) typeDeclName TypeParams?
    Constructor?
    Delegation?
    TypeConstraints?
    ClassBody?
  }

  context Constructor { (Modifier* constructor)? ParamList }

  TypeConstraints {
    where commaSep1(Annotation* variableName ":" Type)
  }

  ObjectDeclaration {
    object declName Delegation? ClassBody?
  }

  context FunctionSpec {
    ParamList (":" Type)? TypeConstraints? (Block | op("=") Expression)
  }

  context Block { "{" Statement* "}" }

  PropertyDeclaration {
    valVar TypeParams? VariableDeclaration
    TypeConstraints? (op("=") Expression | kw("by") Expression)? ";"?
    (Getter (";" Setter)? | Setter (";" Getter?))?
  }

  VariableDeclaration {
    "(" commaSep1(VariableDeclaration) ")" | Annotation* declName (":" Type)?
  }

  Getter {
    Modifier* kw("get") ("(" ")")? (":" Type)? (Block | op("=") Expression)
  }

  Setter {
    Modifier* kw("set") ParamList? (":" Type)? (Block | op("=") Expression)
  }

  TypeAlias {
    typealias typeDeclName TypeParams? op("=") Type ";"?
  }

  context ClassBody {
    "{" ClassItem* "}"
  }

  ClassItem {
    Annotation |
    Declaration |
    companion object identifier? Delegation? ClassBody? |
    init Block |
    constructor ParamList (":" (this | super_) ArgList)? Block? |
    EnumList
  }

  EnumList {
    commaSep1(Modifier* declName ArgList? ClassBody?) ";"
  }

  Delegation { ":" commaSep1(Modifier* Type (kw("by") Expression | ArgList)?) }

  context ParamList {
    "(" commaSep(Modifier* valVar? declName (":" Type)? (op("=") Expression)?) ")"
  }

  context ArgList {
    "(" commaSep(Annotation* (~(identifier "=") identifier op("="))? "*"? Expression) ")"
  }

  ForStatement {
    for "(" Annotation* VariableDeclaration in Expression ")" (Block | Statement)
  }

  Annotation {
    AnnotationHead (UnescapedAnnotation | "[" UnescapedAnnotation+ "]")
  }

  UnescapedAnnotation { (annotationName TypeParams?) ("." annotationName TypeParams?)* ArgList? }

  WhenExpression {
    when "(" (Annotation* kw("val") VariableDeclaration op("="))? Expression ")" WhenBody
  }

  context TypeArgs {
    "<" commaSep1("*" | (Annotation | kw("in" | "out"))* Type) ">"
  }

  context TypeParams {
    "<" commaSep1(Modifier* typeName (":" Type)?) ">"
  }

  context Lambda {
    "{" (~(VariableDeclaration "->") VariableDeclaration op("->"))? Statement* "}"
  }

  context ParenthesizedExpression { "(" Expression ")" }

  context WhenBody { "{" WhenEntry "}" }

  WhenEntry {
    (else | commaSep1(~("!"? in) op("!")? in Expression | ~("!"? is) op("!")? is Type | Expression))
    op("->") (Block | Statement | ";")
  }

  context ParamTypeList {
    "(" commaSep((~(identifier ":") identifier ":")? Type) ")"
  }

  stringInterpol {
    str("${") Expression str("}")
  }
}

skip skipNoNL {
  TopItem {
    package l packageName l ("." packageName)* ";"? |
    import l (identifierDot ".")* ("*" | declName (as declName)?) ";"? |
    Statement
  }

  context Statement {
    label |
    Annotation |
    Declaration |
    ForStatement |
    while l ParenthesizedExpression l (Block | Statement | ";") |
    do l (Block | Statement) l while l ParenthesizedExpression |
    Expression ";"? |
    ";"
  }

  AnnotationHead="meta" {
    "@" (~(identifier ":") identifier ":")?
  }

  Modifier { modifierKw | Annotation }

  ExpressionInner {
    ParenthesizedExpression |
    atom |
    number |
    string |
    char |
    Lambda |
    object l (Delegation l)? ClassBody |
    fun l FunctionSpec |
    this ("@" identifier)? |
    super_ ("<" l Type l ">")? ("@" identifier)? |
    if l ParenthesizedExpression l (Block | Statement | ";") Alternative |
    WhenExpression |
    try l Block CatchFinally |
    throw Expression |
    return ("@" identifier)? Expression? |
    breakCont ("@" identifier)? |
    calleeClassName |
    className |
    calleeName |
    variableName
  }

  context Alternative {
    (~(l else) l else l (Block | Statement | ";"))?
  }

  context CatchFinally {
    (~(l catch) l catch l "(" l (Annotation l)* declName l ":" l Type l ")" l Block)*
    (~(l finally) l finally l Block)?
  }

  Expression {
    ((prefixOp | label | Annotation) l)* ExpressionInner ExpressionSuffix*
  }

  ExpressionSuffix {
    suffixOp |
    (~TypeArgs TypeArgs) |
    (binOp | "!"? (in | as) | as "?"?) l ExpressionInner |
    ArgList |
    ("?." | "." | "::") l (class | propertyCallee | propertyName | ParenthesizedExpression) |
    "[" l commaSep1(Expression) l "]" |
    infixCallee l ExpressionInner
  }

  TypeInner {
    dynamic |
    typeName ("." l typeName)* |
    (~("(" l (AnnotationHead | identifier l (")" l "->" | ":"))) ParamTypeList l op("->") l Type) |
    "(" l Type l ")"
  }

  Type {
    ((Annotation | kw("suspend")) l)* TypeInner "?"*
  }

  commaSep(inner) { commaSep1(inner)? }

  commaSep1(inner) { inner ("," l inner?)* }
}

tokens {
  class { kw("class") }
  interface { kw("interface") }
  object { kw("object") }
  constructor { kw("constructor") }
  fun { kw("fun") }
  typealias { kw("typealias") }
  init { kw("init") }
  companion { kw("companion") }
  where { kw("where") }
  return { kw("return") }
  if { kw("if") }
  else { kw("else") }
  when { kw("when") }
  for { kw("for") }
  while { kw("while") }
  do { kw("do") }
  breakCont { kw("break" | "continue") }
  in { kw("in") }
  is { kw("is") }
  as { kw("as") }
  dynamic { kw("dynamic") }
  modifierKw { kw("enum" | "sealed" | "annotation" | "data" | "inner" | "override" | "lateinit" |
                  "public" | "private" | "internal" | "protected" | "tailred" | "operator" | "infix" |
                  "inline" | "external" | "extend" | "const" | "abstract" | "final" | "open" |
                  "vararg" | "noinline" | "crossinline" | "reified" | "expect" | "actual") }
  this { kw("this") }
  super_ { kw("super") }
  throw { kw("throw") }
  try { kw("try") }
  catch { kw("catch") }
  finally { kw("finally") }
  package { kw("package") }
  import { kw("import") }
  valVar { kw("val" | "var") }

  atom="atom" { ("true" | "false" | "null") !identifierChar }

  number="number" {
    (("0x" | "0X") (digit | "_" | "a"-"f" | "A"-"F")+ |
     ("0b" | "0B") ("0" | "1" | "_")+ |
     (digit (digit | "_")* ("." (digit | "_")*)? | "." (digit | "_")+) (("e" | "E") ("+" | "-")? (digit | "_")+)?)
    ("u" | "U")? "L"?
  }

  string {
    str("\"\"\"") (str("\\" _) | stringInterpol | str((!("\"\"\"" | "${" | "\\") _)+))* str("\"\"\"") |
    str("\"") (str("\\" _) | stringInterpol | str((!("\"" | "${" | "\\") .)+))* str("\"")
  }

  char="string-2" {
    "'" ("\\" . (!"'" .)* | .) "'"
  }

  binOp="operator" {
    ".." | "?:" | ("+" | "-" | "*" | "/" | "%" | "<" | ">") "="? | ("!" | "=") "=" "="? | "=" | "&&" | "||"
  }

  comment="comment" { doccomment.comment | "/*" (!"*/" _)* "*/" | "//" .* }
}

identifier { identifierStart identifierChar* | "`" (!"`" .)+ "`" }

annotationHead="meta" { "@" identifier }

label="meta" { identifier "@" }

whitespace {
  (" " | "\t" | "\r")+ | comment
}

skipAny { (whitespace | "\n")* }

skipNoNL { whitespace* }

l { ("\n" whitespace*)* }

declName="def" { identifier }

typeDeclName="type def" { identifier }

typeName="type" { identifier }

variableName="variable" { identifier }

calleeName="variable callee" { identifier ~(" "* "(") }

className="type" { "A"-"Z" identifierChar* }

calleeClassName="callee" { className }

infixCallee="variable callee" { !else identifier }

propertyName="property" { identifier }

propertyCallee="property callee" { identifier ~(" "* "(") }

packageName="variable package" { identifier }

annotationName="meta" { identifier }

identifierDot { identifier ~(" "* ".") }

kw(value)="keyword" { value !identifierChar }
op(value)="operator" { value }
str(expr)="string" { expr }

suffixOp { op("++" | "--" | "!!") }

prefixOp { op("++" | "--" | "+" | "-" | "!") }

maybe(value) { ~value value }

letter { "a"-"z" | "A"-"Z" | "\u00a1"-"\uffff" | "_" }

digit { "0"-"9" }

identifierStart { letter }

identifierChar { letter | digit }

spaceChar { "\n" | "\t" | " " }

shebang="meta" { "#!" .* }

